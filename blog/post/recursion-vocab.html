<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Blogo" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" inline href="/blog/assets/normalize.css">
  <link rel="stylesheet" inline href="/blog/assets/main.css">
  <link rel="alternate" href="/blog/index.xml" type="application/rss+xml" title="Sina Siadat">
  <title>Recursion vocabulary</title>
</head>
<body>
  <div id="everything">
  <header role="banner">
    <a href="/index.html">Sina Siadat</a>
  </header>
  <hr>
  <div class="header">
             <a href="/index.html">about me</a>
    &middot; <a href="/blog/index.html">blog</a>
    &middot; <a href="/projects.html">projects</a>
    &middot; <a href="/reading.html">reading</a>
    &middot; <a href="/music.html">music</a>
    <!--&middot; <a href="/photography.html">photography</a>-->
    &middot; <a href="https://github.com/siadat/">github</a>
    &middot; <a href="https://twitter.com/sinasiadat">twitter</a>
    <!--&middot; <a href="https://instagram.com/siadat">instagram</a>-->
    <!--&middot; <a href="https://www.goodreads.com/user/show/8642755-sina">goodreads</a>-->
    <!--&middot; <a href="index.xml">rss</a>-->
  </div>
  <hr>
  <div>Blog post published on
    
      <time itemprop="datePublished" datetime="January 22, 2020">
        January 22, 2020
      </time>
    
  </div>
  <hr>

  <main role="main">
    <article itemscope itemtype="http://schema.org/BlogPosting">
      <h1 class="entry-title" itemprop="headline">Recursion vocabulary</h1>
      <section itemprop="entry-text">
        <blockquote>
<p>In this post, I write that the existing terminology for <a href="https://en.wikipedia.org/wiki/Call_stack" target="_blank">call stacks</a>
is not enough, and we need new words for thinking about
recursive call stacks, and I consider a couple of possible words
that are suited for reading and reasoning about functions,
namely &ldquo;upstream&rdquo; (closer to initial caller) and &ldquo;downstream&rdquo; (closer to the
top of the call stack).
However, they are not perfect as they do not match perfectly with the call stack terminology.</p>
</blockquote>

<p>The vocabulary used by call stacks is detail oriented.
The focus of this post is to describe a logical or algorithmic
view of how functions communicate, as opposed to call stacks and
implementation details.</p>

<p>In a normal call stack, data flows
in several directions:</p>

<ul>
<li>from the function that called us</li>
<li>back to the function that called us</li>
<li>to one or more functions we call</li>
<li>from one of more functions we call</li>
</ul>

<p>Hence, data flows in 4 different ways via arguments and return values.
As a special case,
recursive functions are even more complex
because they share the same signatures and variable names
with the functions they are communicating with.</p>

<p>I think it would be a good idea to have a few names to differentiate these flows.
We could think of a caller functions as logically <strong>upstream</strong> to the function it calls,
and the called functions as logically <strong>downstream</strong> to its caller.
So, when a function calls another function (or itself), we are momentarily going downstream,
until that function returns and we are back.</p>

<p>When reading a function, we are focused on teh current stack,
and the functions we call are hiding complexity behind an invocation.
That&rsquo;s why I think the called functions go &ldquo;down&rdquo; or somewhere less important that the
current function&rsquo;s scope, and that I don&rsquo;t want to think of them as coming &ldquo;up&rdquo;
and get closer to my face (as seems to be the case in call stack terminology).</p>

<p>The problem is that these flows are not exactly &ldquo;streams&rdquo;.
We are sending data down and up, but not in a continuous way.
Perhaps &ldquo;send down&rdquo; and &ldquo;send up&rdquo;, or &ldquo;bubble up&rdquo; and &ldquo;sink down&rdquo; would be better alternatives.
At least temporarily, I am going to stick with &ldquo;upstream&rdquo; and &ldquo;downstream&rdquo; for the rest of this post,
because it sounds natural to use them as adjectives for functions, we can talk about
an &ldquo;upstream function&rdquo; (the function that called us)
and a &ldquo;downstream function&rdquo; (the function that we call).</p>

<p>Each function invocation is connected to 2 other functions in 2 directions each
(except the original caller and the terminating invocations, having 2 arrows each):</p>

<ol>
<li>from upstream: we receive data from upstream via our arguments.</li>
<li>to downstream: we send data to downstream by setting the argument of the function we call.</li>
<li>from downstream: we receive data from the functions we call via their return values.</li>
<li>to upstream: we send data to upstream by returning values.</li>
</ol>

<p>We are always first going downstream, then upstream.</p>

<p>In an attempt to be compatible with the stack view of call stacks,
we can image the stack growing down with its &ldquo;top&rdquo; at the bottom.</p>
<div class='shell'>
<pre><code class="language-shell">    |
    |  t1  t2  t3  t4  t5  t6  t7  (time)
    |                              
    |  4!  4!  4!  4!  4!  4!  4!  (the function we are reading)
    |  ==  --  --  --  --  --  ==
    |      3!  3!  3!  3!  3!
    |      ==  --  --  --  ==
    |          2!  2!  2!
    |          ==  --  ==
    |              1!
    |              ==
    |
    v
  stack
    &amp;
downstream
directions
</code></pre>
</div>
<h2>Examples</h2>

<p>Here is a head recursive factorial function (arrows show the direction of the flow of data):</p>

<pre><code class="language-ml">let rec factorial n =
  match n with
  | 1 -&gt; 1
  | _ -&gt; n * factorial (n-1)

assert (factorial 4 = 24)
</code></pre>
<div class='shell'>
<pre><code class="language-shell">  upstream
     ↑
     |
     |
time +----(4)----(3)----(2)----(1)----------1---2---6---24---&gt;
     |
     |     4! = ..................................... = 24
     |     ↓                                            ↑
     |     ↓                                            ↑
     |     ↓                                            ↑
     |     ↓                                            ↑
     |     ↓                                            ↑
     |     4! = 4x3! = ........................ = 4x6 = 24
     |            ↓                                 ↑
     |            ↓                                 ↑
     |            ↓                                 ↑
     |            ↓                                 ↑
     |            ↓                                 ↑
     |            3! = 3x2! = ............. = 3x2 = 6
     |                   ↓                      ↑
     |                   ↓                      ↑
     |                   ↓                      ↑
     |                   ↓                      ↑
     |                   ↓                      ↑
     |                   2! = 2x1! = .. = 2x1 = 2
     |                          ↓           ↑
     |                          ↓           ↑
     |                          ↓           ↑
     |                          ↓           ↑
     |                          ↓           ↑
     |                          1!    is    1
     |
     ↓
 downstream
</code></pre>
</div>
<p>As another example, here is a tail recursive function for calculating the factorial
of a number:</p>

<pre><code class="language-ml">let rec factorial n accum =
  match n with
  | 1 -&gt; accum
  | _ -&gt; factorial (n-1) (n*accum)

assert (factorial 4 1 = 24)
</code></pre>
<div class='shell'>
<pre><code class="language-shell">  upstream
     ↑
     |
     |
time +----(4,1)-(3,4)-(2,12)-(1,24)----------------------24---&gt;
     |
     |     4,1   = ................................... = 24
     |           ↓                                       ↑
     |           ↓                                       ↑
     |           ↓                                       ↑
     |           ↓                                       ↑
     |           ↓                                       ↑
     |           3,1x4 = ............................. = 24
     |                 ↓                                 ↑
     |                 ↓                                 ↑
     |                 ↓                                 ↑
     |                 ↓                                 ↑
     |                 ↓                                 ↑
     |                 2,1x4x3 = ..................... = 24
     |                         ↓                         ↑
     |                         ↓                         ↑
     |                         ↓                         ↑
     |                         ↓                         ↑
     |                         ↓                         ↑
     |                         1,1x4x3x2 = ........... = 24
     |                                   ↓               ↑
     |                                   ↓               ↑
     |                                   ↓               ↑
     |                                   ↓               ↑
     |                                   ↓               ↑
     |                                   0,1x4x3x2x1 = 0,24
     |
     ↓
 downstream
</code></pre>
</div>
<p>In this example, we could say that
we are &ldquo;receiving (n) and (accum) from upstream&rdquo;,
we are &ldquo;passing (n-1) and (n*accum) to downstream&rdquo;,
and the last call to the function &ldquo;returns accum back upstream,&rdquo;
which is in trun directly &ldquo;returned back upstream&rdquo; (tail recursion).</p>

<p>In a tail recursive function, the value is calculated while going downstream.
The final value is first known by the most downstream invocation.</p>

<p>In a head recursive function, the final value is calculated while going back upstream.
The final value is only known by the most upstream invocation.</p>

<p>This post will probably be edited in the future,
because I am not quite satisfied with it yet.</p>

      </section>
    </article>
  </main>

  <hr>
  <div>
    End of the post. Let me know your opinion via <a href="https://twitter.com/sinasiadat">twitter/sinasiadat</a>.
  </div>

</body>
</html>
