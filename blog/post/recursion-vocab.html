<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Blogo" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" inline href="/blog/assets/normalize.css">
  <link rel="stylesheet" inline href="/blog/assets/main.css">
  <link rel="alternate" href="/blog/index.xml" type="application/rss+xml" title="Sina Siadat">
  <title>Recursion vocabulary</title>
</head>
<body>
  <div id="everything">
  <header role="banner">
    <a href="/index.html">Sina Siadat</a>
  </header>
  <hr>
  <div class="header">
             <a href="/index.html">about me</a>
    &middot; <a href="/blog/index.html">blog</a>
    &middot; <a href="/projects.html">projects</a>
    &middot; <a href="/reading.html">reading</a>
    &middot; <a href="/music.html">music</a>
    <!--&middot; <a href="/photography.html">photography</a>-->
    &middot; <a href="https://github.com/siadat/">github</a>
    &middot; <a href="https://twitter.com/sinasiadat">twitter</a>
    <!--&middot; <a href="https://instagram.com/siadat">instagram</a>-->
    <!--&middot; <a href="https://www.goodreads.com/user/show/8642755-sina">goodreads</a>-->
    <!--&middot; <a href="index.xml">rss</a>-->
  </div>
  <hr>
  <div>Blog post published on
    
      <time itemprop="datePublished" datetime="January 22, 2020">
        January 22, 2020
      </time>
    
  </div>
  <hr>

  <main role="main">
    <article itemscope itemtype="http://schema.org/BlogPosting">
      <h1 class="entry-title" itemprop="headline">Recursion vocabulary</h1>
      <section itemprop="entry-text">
        <p>In this post, I write that the existing terminology for <a href="https://en.wikipedia.org/wiki/Call_stack" target="_blank">call stacks</a>
is not enough, and we need new terms for thinking about
recursive call stacks. Furthermore, I consider a couple of terms
that seem to help with reading and reasoning about recursive functions,
namely &ldquo;upstream&rdquo; (closer to initial caller) and &ldquo;downstream&rdquo;.
However, these terms are not perfect as they do not match perfectly with the
call stack terminology, but they help me convey more information in fewer words
which helps while reasoning about a recursive algorithm.</p>

<h2>Problem</h2>

<p>In a normal call stack, data flow
in several directions:</p>

<ul>
<li>from the function that called us</li>
<li>back to the function that called us</li>
<li>to one or more functions we call</li>
<li>from one of more functions we call</li>
</ul>

<p>Hence, data flow in 4 different channels via arguments and return values.
As a special case, recursive functions are even more complex
because they share the same signatures and variable names
with the functions they are communicating with.</p>

<h2>Solution 1: &ldquo;caller&rdquo; and &ldquo;called&rdquo; functions</h2>

<p>We could refer to the function we are calling as the &ldquo;called function.&rdquo;
But this does not distinguish that function from any other called function in the program.
A more appropriate, albeit long, phrase would be &ldquo;the function we call.&rdquo;
And we could refer to the function that called us as &ldquo;the function that called us.&rdquo;</p>

<h2>Solution 2: stack &ldquo;push&rdquo; and &ldquo;pop&rdquo;</h2>

<p>We could refer to the function we are calling as being &ldquo;pushed on top of the stack&rdquo;
and when it returns it will be &ldquo;popped from the top of the stack.&rdquo;</p>

<p>The vocabulary used to describe call stacks is motivated by the details of how memory is managed.
The focus of this post is to find a way to describe the logical and algorithmic
flow of communication, as opposed to call-stacks and implementation details.</p>

<h2>Solution 3: &ldquo;upstream&rdquo; and &ldquo;downstream&rdquo;</h2>

<p>I think it would be a good idea to have a couple of new terms to differentiate the direction of flows
between function calls.
We could think of a caller function as logically <strong>upstream</strong> to the function it calls,
and the called functions as logically <strong>downstream</strong> to its caller.
So, when a function calls another function (or itself), we are momentarily going downstream,
until that function returns and we are back.</p>

<p>When reading a function, we are focused on the current stack,
and the functions we call are hiding complexity behind an invocation.
That&rsquo;s why I think the called functions go &ldquo;down&rdquo; or somewhere less important than the
current function&rsquo;s scope, and that I don&rsquo;t want to think of them as coming &ldquo;up&rdquo;
and get closer to my face (as seems to be the case in call stack terminology).</p>

<p>The problem is that these flows are not exactly &ldquo;streams&rdquo;.
We are sending data down and up, but not in a continuous way.
Perhaps &ldquo;send down&rdquo; and &ldquo;send up&rdquo;, or &ldquo;bubble up&rdquo; and &ldquo;sink down&rdquo;, or &ldquo;push&rdquo;
and &ldquo;pull&rdquo; would be better alternatives.
But I am more concerned about the direction of the flow as opposed to individual actions.
At least temporarily, I am going to stick with &ldquo;upstream&rdquo; and &ldquo;downstream&rdquo; for the rest of this post,
because it sounds natural to use them as adjectives for functions, we can talk about
an &ldquo;upstream function&rdquo; (the function that called us)
and a &ldquo;downstream function&rdquo; (the function that we call).</p>

<p>Each function invocation is connected to 2 other functions in 2 directions each
(except the original caller and the terminating invocations, having 2 arrows each):</p>

<ol>
<li>from upstream: we receive data from upstream via our arguments.</li>
<li>to downstream: we send data to downstream by setting the argument of the function we call.</li>
<li>from downstream: we receive data from the functions we call via their return values.</li>
<li>to upstream: we send data to upstream by returning values.</li>
</ol>

<p>With these words, we will be able to talk about the &ldquo;upstream flow of data&rdquo; or
the &ldquo;downstream flow of data&rdquo;.</p>

<p>We are always first going downstream, then upstream.</p>

<p>In an attempt to be compatible with the stack view of call stacks,
we can image the stack growing down with its &ldquo;top&rdquo; at the bottom.</p>
<div class='output'>
<pre><code class="language-output">    |
    |  t1  t2  t3  t4  t5  t6  t7  (time)
    |                              
    |  4!  4!  4!  4!  4!  4!  4!  (the function we are reading)
    |  ==  --  --  --  --  --  ==
    |      3!  3!  3!  3!  3!
    |      ==  --  --  --  ==
    |          2!  2!  2!
    |          ==  --  ==
    |              1!
    |              ==
    |
    v
  stack
    &amp;
downstream
directions
</code></pre>
</div>
<h2>Examples</h2>

<h3>Describing head and tail recursion</h3>

<p>We could use &ldquo;upstream&rdquo; and &ldquo;downstream&rdquo; to say the following:</p>

<ul>
<li>In a tail recursive function, the value is calculated while &ldquo;going downstream&rdquo;.
The final value is first known by the &ldquo;most downstream invocation&rdquo;.</li>
<li>In a head recursive function, the final value is calculated while &ldquo;going back upstream&rdquo;.
The final value is only known by the &ldquo;most upstream invocation&rdquo;.</li>
</ul>

<h3>Visualizations</h3>

<p>To help the reader visualize the up and down directions, here is a head recursive factorial function (arrows show the direction of the flow of data):</p>

<pre><code class="language-ml">let rec factorial n =
  match n with
  | 1 -&gt; 1
  | _ -&gt; n * factorial (n-1)

assert (factorial 4 = 24)
</code></pre>
<div class='output'>
<pre><code class="language-output">  upstream
     ↑
     |
     |
time +----(4)----(3)----(2)----(1)----------1---2---6---24---&gt;
     |
     |     4! = ..................................... = 24
     |     ↓                                            ↑
     |     ↓                                            ↑
     |     ↓                                            ↑
     |     ↓                                            ↑
     |     ↓                                            ↑
     |     4! = 4x3! = ........................ = 4x6 = 24
     |            ↓                                 ↑
     |            ↓                                 ↑
     |            ↓                                 ↑
     |            ↓                                 ↑
     |            ↓                                 ↑
     |            3! = 3x2! = ............. = 3x2 = 6
     |                   ↓                      ↑
     |                   ↓                      ↑
     |                   ↓                      ↑
     |                   ↓                      ↑
     |                   ↓                      ↑
     |                   2! = 2x1! = .. = 2x1 = 2
     |                          ↓           ↑
     |                          ↓           ↑
     |                          ↓           ↑
     |                          ↓           ↑
     |                          ↓           ↑
     |                          1!    is    1
     |
     ↓
 downstream
</code></pre>
</div>
<p>As another example, here is a tail recursive function for calculating the factorial
of a number:</p>

<pre><code class="language-ml">let rec factorial n accum =
  match n with
  | 1 -&gt; accum
  | _ -&gt; factorial (n-1) (n*accum)

assert (factorial 4 1 = 24)
</code></pre>
<div class='output'>
<pre><code class="language-output">  upstream
     ↑
     |
     |
time +----(4,1)-(3,4)-(2,12)-(1,24)----------------------24---&gt;
     |
     |     4,1   = ................................... = 24
     |           ↓                                       ↑
     |           ↓                                       ↑
     |           ↓                                       ↑
     |           ↓                                       ↑
     |           ↓                                       ↑
     |           3,1x4 = ............................. = 24
     |                 ↓                                 ↑
     |                 ↓                                 ↑
     |                 ↓                                 ↑
     |                 ↓                                 ↑
     |                 ↓                                 ↑
     |                 2,1x4x3 = ..................... = 24
     |                         ↓                         ↑
     |                         ↓                         ↑
     |                         ↓                         ↑
     |                         ↓                         ↑
     |                         ↓                         ↑
     |                         1,1x4x3x2 = ........... = 24
     |                                   ↓               ↑
     |                                   ↓               ↑
     |                                   ↓               ↑
     |                                   ↓               ↑
     |                                   ↓               ↑
     |                                   0,1x4x3x2x1 = 0,24
     |
     ↓
 downstream
</code></pre>
</div>
<p>For the tail recursive example, we could say:</p>

<ul>
<li>In the tail recursive example, we are &ldquo;receiving (n) and (accum) from upstream&rdquo;</li>
<li>In the tail recursive example, we are &ldquo;passing (n-1) and (n*accum) to downstream&rdquo;</li>
<li>In the tail recursive example, the last invocations &ldquo;returns accum back upstream&rdquo;</li>
</ul>

<h2>Conclusion</h2>

<p>We do not have a vocabulary for describing the logical flows of data between
function calls. One potential candidate is to use &ldquo;upstream&rdquo; and &ldquo;downstream&rdquo;
to describe the direction of the data, which seems to facilitate talking and
reasoning about recursive functions.</p>

      </section>
    </article>
  </main>

  <hr>
  <div>
    End of the post. Let me know your opinion via <a href="https://twitter.com/sinasiadat">twitter/sinasiadat</a>.
  </div>

</body>
</html>
